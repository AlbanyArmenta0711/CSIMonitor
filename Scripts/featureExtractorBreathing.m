%Script that loads CSI csv file generated by Activity_datfile_to_csvfile
%script, process CSI amplitude and extract time and frequency domain
%features in order to generate a dataset.
%RESULT: breathing dataset matrix 

clc; clear;
%Load CSI File
fileName = 's1_18BPM.csv'; %Path/Name of the CSI csv file to be loaded
csiFile = load(fileName); 

%Separate CSI amplitudes and phase in two different numeric matrices
csiAmps = csiFile(:,2:91); %Column 1 is the timestamp
csiPhases = csiFile(:,92:181); 

%Load CSI File with Breathing Ground-Truth
groundTruthFileName = '18BPMGroundTruth.mat';
RealBR = load(groundTruthFileName);
RealBR = RealBR.BREstimation;

%For Breathing Feature Extractor, only CSI amplitudes are used
fs = 25; %Sample frequency in Hz
t = 40; %Length of time window in seconds
sc = 10; %Number of sensitive subcarriers to be used for feature extraction
%Breathing Estimation feature is averaged with the last 3 breathing
%estimations to avoid abrupt changes
lastF = NaN; 
lfSize = 3; %number of means to consider for each estimation
lfIndex = 1; 
[numData,~] = size(csiAmps);
dur = ceil(numData/fs)-t; 

%Define feature vectors/matrices
CD1Var = zeros(dur,sc); %Variance of Detailed Coefficients of each sc
CD2Var = zeros(dur,sc);
CD3Var = zeros(dur,sc);
CD4Var = zeros(dur,sc);
ApproxVar = zeros(dur,sc); %Variance of Approximation Coefficients of each sc
CD1Mean = zeros(dur,sc);
CD2Mean = zeros(dur,sc);
CD3Mean = zeros(dur,sc);
CD4Mean = zeros(dur,sc);
ApproxMean = zeros(dur,sc); %Mean of Approximation Coefficients of each sc
MeanSC = zeros(dur,sc);  %Time domain Mean 
VarSC = zeros(dur,sc);  %Time domain Variance
SkwSC = zeros(dur,sc);  %Time domain Skewness
KurtSC = zeros(dur,sc);     %Time domain Kurtosis
MAVSC = zeros(dur,sc); %Time domain MEAN ABSOLUTE VALUE
SSISC = zeros(dur,sc); %Time domain SIMPLE SIGN INTEGRAL
RMSSC = zeros(dur,sc); %Time domain ROOT MEAN SQUARE
BREstimation = zeros(dur,1); %First Breathing Rate Estimation
MaxFreq = zeros(dur,sc); %Max Frequency of Power Spectrum of each sc
SpectrumSTD = zeros(dur,sc); %Standard Deviation of Power Spectrum of each sc
atributesIndex = 1; 

%Design bandpass filter
filterOrder = 8; 
filter = designfilt('bandpassiir','FilterOrder',filterOrder, ...
    'HalfPowerFrequency1',0.1,'HalfPowerFrequency2',0.4,  ...
    'SampleRate',fs);
[b,a] = sos2tf(filter.Coefficients);

%Treat csi amplitudes in time windows of t duration 

for i = 1:fs:numData - (numData - (dur*fs))
    upperBound = i+t*fs-1;
    if upperBound > numData
        upperBound = numData; 
    end
    csiWindow = csiAmps(i:upperBound,:);
    [rows,cols] = size(csiWindow);
    r = round(rows/5);
    
    %Start Data Calibration
    if r > 0
        %Hampel Identifier 
        [csiHampel,hampelIndex] = hampel(csiWindow,round(rows/5),2); 
        maf = csiHampel;
        for j = 1:cols %Savitzky-Golay Filter to each sc
            if round(rows/10) > 0 
                maf(:,j) = sgolayfilt(csiHampel(:,j),3,51);                
            end
        end 
        if i == 1 
            dataCalibrated = filtfilt(b,a,maf);
        else 
            dataCalibrated = filtfilt(b,a,maf);
        end
        if i == 1
            [dataCalibrated,indexes] = subcarrierSelection(dataCalibrated,sc);
        else
            dataCalibrated = dataCalibrated(:,indexes);
        end  
        
        %Once calibrated, proceed with feature extraction
        %DWT for obtaining detailed and approx coefficients
        mafSensitive = maf(:,indexes);  
        for currentsc=1:sc
            [c,l] = wavedec(mafSensitive(:,currentsc),4,'db2');
            approx = appcoef(c,l,'db2');
            [cd1,cd2,cd3,cd4] = detcoef(c,l,[1 2 3 4]);
            %Normalize each coefficients between 0 and 1 
            cd1Norm = normalize(cd1,'range',[0 1]);
            cd2Norm = normalize(cd2,'range',[0 1]);
            cd3Norm = normalize(cd3,'range',[0 1]);
            cd4Norm = normalize(cd4,'range',[0 1]);
            approxNorm = normalize(approx,'range',[0 1]); 
            %DWT Feature Extraction
            CD1Var(atributesIndex,currentsc) = std(cd1Norm);          
            CD2Var(atributesIndex,currentsc) = std(cd2Norm);           
            CD3Var(atributesIndex,currentsc) = std(cd3Norm);           
            CD4Var(atributesIndex,currentsc) = std(cd4Norm);            
            CD1Mean(atributesIndex,currentsc) = mean(cd1Norm);          
            CD2Mean(atributesIndex,currentsc) = mean(cd2Norm);           
            CD3Mean(atributesIndex,currentsc) = mean(cd3Norm);           
            CD4Mean(atributesIndex,currentsc) = mean(cd4Norm);  
            ApproxVar(atributesIndex,currentsc) = var(approxNorm);
            ApproxMean(atributesIndex,currentsc) = mean(approxNorm);
        end
        %Obtain Frequency Domain of sensitive calibrated subcarriers
        n = 2^nextpow2(rows);
        X = fft(dataCalibrated,n);
        X = X./max(X);
        X = fftshift(X);
        psd = abs(X);
        kk = 0:n-1;
        F = kk/n*fs-fs/2;
        [~,index] = find(F==0);
        F = F(index:n);
        psd = psd(index:n,:);
        
        [rows,cols] = size(psd);
        meanPSD = zeros(rows,1); 
        for j=1:rows
            meanPSD(j) = mean(psd(j,:)); 
        end 
        [maxAmplitudes,indexMaxFrequencies] = maxk(meanPSD,5);
        frequency = F(indexMaxFrequencies); 
        err = zeros(length(frequency),1);  
        if atributesIndex == 170
            test = 1; 
        end
        if isnan(lastF) %if first estimation...
            lastF = frequency(1); %Max frequency in frequency domain
            nearestF = lastF;   
            lastEstimations(1) = lastF; 
            lfIndex = lfIndex + 1; 
        else
            if lfIndex < lfSize
                lastEstimations(lfIndex) = (sum(lastEstimations) + frequency(1))/(numel(lastEstimations)+1); 
                nearestF = lastEstimations(lfIndex);
                lfIndex = lfIndex + 1; 
            else                           
                lfIndex = 1; 
                lastEstimations(lfIndex) = (sum(lastEstimations) + frequency(1))/lfSize;
                nearestF = lastEstimations(lfIndex);
            end
        end 
        %Normalize calibrated signals between 0 and 1 
        calibratedNorm = normalize(dataCalibrated,'range',[0 1]);      
        %MEAN ABSOLUTE VALUE
        MAVSC(atributesIndex,:) = mean(abs(dataCalibrated));
        %SIMPLE SIGN INTEGRAL
        SSISC(atributesIndex,:) = sum(abs(dataCalibrated).^2);
        %ROOT MEAN SQUARE
        RMSSC(atributesIndex,:) = sqrt(SSISC(atributesIndex,:)./rows);
        %Mean of each calibrated signal
        MeanSC(atributesIndex,:) = mean(calibratedNorm);
        %Variance of each calibrated signal
        VarSC(atributesIndex,:) = var(calibratedNorm); 
        %Skewness of each calibrated signal
        SkwSC(atributesIndex,:) = skewness(calibratedNorm);
        %Kurtosis of each calibrated signal
        KurtSC(atributesIndex,:) = kurtosis(calibratedNorm);
        %First Estimation
        BREstimation(atributesIndex) = round(60*nearestF);
        [~,maxPos] = max(psd);    
        %MAX FREQUENCY IN POWER SPECTRUM
        MaxFreq(atributesIndex,:)=F(maxPos);
        %STANDARD DEVIATION OF POWER SPECTRUM
        SpectrumSTD(atributesIndex,:) = std(psd); 
        
        atributesIndex = atributesIndex + 1; 
    end 
end 

%Dataset creation
[~,c] = size(CD1Var);
for i = 1:c
    index = mod(i,c); 
    if index == 0
        index =c; 
    end 
    headers(i) = strcat('CD1Var',sprintf("%d",index)); 
end 
[~,cC] = size(headers);
[~,c] = size(CD2Var); 
for i = cC+1:cC+c 
    index = mod(i,c); 
    if index == 0
        index = c; 
    end
    headers(i) = strcat('CD2Var',sprintf("%d",index));
end
[~,cC] = size(headers);
[~,c] = size(CD3Var); 
for i = cC+1:cC+c 
    index = mod(i,c); 
    if index == 0
        index = c; 
    end
    headers(i) = strcat('CD3Var',sprintf("%d",index));
end
[~,cC] = size(headers);
[~,c] = size(CD4Var); 
for i = cC+1:cC+c 
    index = mod(i,c); 
    if index == 0
        index = c; 
    end
    headers(i) = strcat('CD4Var',sprintf("%d",index));
end
[~,cC] = size(headers);
[~,c] = size(CD1Mean); 
for i = cC+1:cC+c 
    index = mod(i,c); 
    if index == 0
        index = c; 
    end
    headers(i) = strcat('CD1Mean',sprintf("%d",index));
end
[~,cC] = size(headers);
[~,c] = size(CD2Mean); 
for i = cC+1:cC+c 
    index = mod(i,c); 
    if index == 0
        index = c; 
    end
    headers(i) = strcat('CD2Mean',sprintf("%d",index));
end
[~,cC] = size(headers);
[~,c] = size(CD3Mean); 
for i = cC+1:cC+c 
    index = mod(i,c); 
    if index == 0
        index = c; 
    end
    headers(i) = strcat('CD3Mean',sprintf("%d",index));
end
[~,cC] = size(headers);
[~,c] = size(CD4Mean); 
for i = cC+1:cC+c 
    index = mod(i,c); 
    if index == 0
        index = c; 
    end
    headers(i) = strcat('CD4Mean',sprintf("%d",index));
end
[~,cC] = size(headers);
[~,c] = size(ApproxMean); 
for i = cC+1:cC+c 
    index = mod(i,c); 
    if index == 0
        index = c; 
    end
    headers(i) = strcat('ApproxMean',sprintf("%d",index));
end
[~,cC] = size(headers);
[~,c] = size(ApproxVar); 
for i = cC+1:cC+c 
    index = mod(i,c); 
    if index == 0
        index = c; 
    end
    headers(i) = strcat('ApproxVar',sprintf("%d",index));
end
[~,cC] = size(headers);
[~,c] = size(MeanSC); 
for i = cC+1:cC+c 
    index = mod(i,c); 
    if index == 0
        index = c; 
    end
    headers(i) = strcat('MeanSC',sprintf("%d",index));
end
[~,cC] = size(headers);
[~,c] = size(MAVSC); 
for i = cC+1:cC+c 
    index = mod(i,c); 
    if index == 0
        index = c; 
    end
    headers(i) = strcat('MAVSC',sprintf("%d",index));
end
[~,cC] = size(headers);
[~,c] = size(SSISC); 
for i = cC+1:cC+c 
    index = mod(i,c); 
    if index == 0
        index = c; 
    end
    headers(i) = strcat('SSISC',sprintf("%d",index));
end
[~,cC] = size(headers);
[~,c] = size(RMSSC); 
for i = cC+1:cC+c 
    index = mod(i,c); 
    if index == 0
        index = c; 
    end
    headers(i) = strcat('RMSSC',sprintf("%d",index));
end
[~,cC] = size(headers);
[~,c] = size(VarSC); 
for i = cC+1:cC+c 
    index = mod(i,c); 
    if index == 0
        index = c; 
    end
    headers(i) = strcat('VarSC',sprintf("%d",index));
end
[~,cC] = size(headers);
[~,c] = size(KurtSC); 
for i = cC+1:cC+c 
    index = mod(i,c); 
    if index == 0
        index = c; 
    end
    headers(i) = strcat('KurtSC',sprintf("%d",index));
end
[~,cC] = size(headers);
[~,c] = size(SkwSC); 
for i = cC+1:cC+c 
    index = mod(i,c); 
    if index == 0
        index = c; 
    end
    headers(i) = strcat('SkwSC',sprintf("%d",index));
end
[~,cC] = size(headers);
[~,c] = size(MaxFreq); 
for i = cC+1:cC+c 
    index = mod(i,c); 
    if index == 0
        index = c; 
    end
    headers(i) = strcat('MaxFreqSC',sprintf("%d",index));
end
[~,cC] = size(headers);
[~,c] = size(SpectrumSTD);
for i = cC+1:cC+c 
    index = mod(i,c); 
    if index == 0
        index = c; 
    end
    headers(i) = strcat('STDPSDSC',sprintf("%d",index));
end
[~,cC] = size(headers);
[~,c] = size(BREstimation);
for i = cC+1:cC+c 
    index = mod(i,c); 
    if index == 0
        index = c; 
    end
    headers(i) = 'FirstEstimation';
end
[~,cC] = size(headers);
[~,c] = size(RealBR);
for i = cC+1:cC+c 
    index = mod(i,c); 
    if index == 0
        index = c; 
    end
    headers(i) = strcat('Label',sprintf("%d",index));
end
dataset =[CD1Var CD2Var CD3Var CD4Var CD1Mean CD2Mean CD3Mean CD4Mean ...
    ApproxMean ApproxVar MeanSC MAVSC SSISC RMSSC VarSC KurtSC SkwSC ...
    MaxFreq SpectrumSTD BREstimation RealBR];
dataset = [headers;dataset];

